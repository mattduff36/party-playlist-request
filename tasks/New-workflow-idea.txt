Decisions

Runtime split

Edge: high-fanout, latency-sensitive, and rate-limited paths

POST /api/requests (guest submit)

GET /api/event/:id (public snapshot)

Node: anything hitting Spotify or doing privileged writes

POST /api/event/:id/status

PATCH /api/requests/:id (approve/reject → enqueue)

POST /api/spotify/enqueue

ORM

Drizzle + Neon HTTP driver for Edge safety

Use Neon pooled connection string for Node routes

Auth

Auth.js v5 (NextAuth) with email/password or OAuth provider for admins

Session: HttpOnly, SameSite=Lax, 7-day rolling

Adapter: Postgres (Neon)

Realtime

Pusher with one namespace per event

Channels

event.{eventId}.state

event.{eventId}.requests

event.{eventId}.nowplaying

Rate limiting

Upstash Redis. Sliding window and burst.

Keys: rl:{eventId}:{ip}

Allow 5 per 10s, 30 per 10m

Hard cap: 429, no DB hit at cap

Spotify ownership

Per-admin tokens in DB

Each event has active_admin_id and device_id

Enqueue picks tokens from active_admin_id

Multiple logins ok; only the event’s active_admin_id is used

API surface

GET /api/event/:id (Edge, public)
returns { id, status, config, device_id, version, updated_at }
cache: revalidate 3s; ETag include version
also returns a compact nowplaying snapshot if you store it

POST /api/event/:id/status (Node, admin)
body { status: “offline|standby|live”, version }
optimistic update WHERE id=? AND version=?
on success, pusher event.{id}.state

POST /api/requests (Edge, public)
rate limit first
body { event_id, track_id, idempotency_key, submitted_by }
writes pending row
pusher event.{id}.requests with delta

PATCH /api/requests/:id (Node, admin)
body { action: “approve” | “reject” }
approve path calls enqueue internally

POST /api/spotify/enqueue (Node, admin/internal)
body { request_id }
loads request → ensures pending → get admin tokens → refresh if needed → Spotify Add To Queue with device_id → mark approved → emit:

event.{id}.requests (status change)

event.{id}.nowplaying (optional compact snapshot)

Data model (Neon)

admins
id uuid pk
email citext unique
name text
created_at timestamptz default now()

admin_sessions
id uuid pk
admin_id uuid fk → admins.id
created_at timestamptz
expires_at timestamptz
user_agent text
ip inet
index(admin_id)

spotify_tokens
admin_id uuid pk → admins.id
refresh_token text encrypted
access_token text
expires_at timestamptz
scope text

events
id uuid pk
name text
status text check in (‘offline’,’standby’,’live’) not null
version int not null default 0
device_id text
active_admin_id uuid fk → admins.id
config jsonb not null default ‘{}’
updated_at timestamptz default now()
index(active_admin_id)

requests
id uuid pk
event_id uuid fk → events.id
track_id text not null
submitted_by text
status text check in (‘pending’,’approved’,’rejected’,’played’) not null default ‘pending’
idempotency_key text
approved_at timestamptz
rejected_at timestamptz
played_at timestamptz
created_at timestamptz default now()
unique(event_id, idempotency_key)
index(event_id, status, created_at desc)

State machine (server-enforced)

Legal transitions: offline↔standby↔live

Enforced only in POST /api/event/:id/status

Clients never hold truth; they read status and render

Edge rate limiting (Upstash)

Sliding window 10s: 5

Secondary window 10m: 30

If over limit, return 429 immediately without DB insert

Emit a small admin notice via Pusher with the offending IP count (optional)

Concurrency and idempotency

Approve path wraps in a short transaction

SELECT … FOR UPDATE request row

check status=pending

enqueue to Spotify

UPDATE status=approved, approved_at

Unique(event_id, idempotency_key) prevents dupes from double-clicks

Event version integer for optimistic updates on status and device selection

Now playing strategy

Don’t poll on the server

Admin page triggers a “refresh nowplaying” action when opened and every 20s while in focus

That action calls Spotify, then emits event.{id}.nowplaying

Display and Home subscribe only; they never call Spotify

Vercel specifics

Edge routes: use Drizzle + Neon HTTP driver, fetch-based

Node routes: use pooled Postgres connection string

Set pusher auth in Node routes only

Use Vercel KV optional cache for GET /api/event/:id to cut read hits further during spikes

Throughput planning for 350 rps

POST /api/requests at Edge avoids cold start penalties

Do not write more than one DB row per request

Pusher emits are cheap; batch optional: emit once per 10 inserts with a counter if load gets wild

Neon: enable connection pooling; keep simple statements; no long transactions

Add a lightweight backpressure: if DB latency > threshold, temporarily increase RL window

Admin UX rules

One switch: set event status

One dropdown: select device

Approve queue: each approve triggers enqueue; show outcome toast

Show last Spotify error inline if device not active

Security

Admin routes check session cookie via Auth.js middleware

CSRF on admin POST/PATCH using Auth.js built-in or a simple double-submit token

Encrypt refresh_token at rest using a KMS key or libsodium sealed box

Minimal migrations order

Create tables above

Backfill current settings into events row

Set default event to standby

Switch UI to read GET /api/event/:id for status

Replace client-side Spotify calls with PATCH /api/requests/:id approve

Concrete payloads

GET /api/event/:id → 200
{ id, status, version, device_id, config, updated_at, nowplaying? }

POST /api/event/:id/status → 200
req: { status, version }
res: { status, version: version+1 }

POST /api/requests → 201
req: { event_id, track_id, idempotency_key, submitted_by }
res: { id, status: “pending” }

PATCH /api/requests/:id → 200
req: { action: “approve” | “reject” }
res: { id, status }

Pusher events
state: { id, status, version, updated_at }
requests: { id, status, track_id, submitted_by, timestamps… }
nowplaying: { track, artists, position_ms, queueCompact[] }